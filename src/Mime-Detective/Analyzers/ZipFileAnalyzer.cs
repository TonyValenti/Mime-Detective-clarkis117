using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Text;

namespace MimeDetective.Analyzers
{
    public class ZipFileAnalyzer : IReadOnlyFileAnalyzer
    {
        public FileType Key { get; } = MimeTypes.ZIP;

        //todo if creating a memorysteam there should be a check for min size to avoid most exceptions
        //should this catch exceptions generated by passing in a zip header but no the whole file?
        /// <summary>
        /// 
        /// </summary>
        /// <param name="readResult"></param>
        /// <returns>Any resulting match or <see cref="MimeTypes.ZIP"/> for no match</returns>
        public FileType Search(in ReadResult readResult)
        {
            bool locallyCreatedStream = false;
            Stream mStream = null;

            if (readResult.Source is null)
            {
                //this should be the length of the array passed via ReadResult
                mStream = new MemoryStream(readResult.Array, 0, readResult.Array.Length);
                locallyCreatedStream = true;
            }
            else
                mStream = readResult.Source;

            if (mStream.CanSeek && mStream.Position > 0)
                mStream.Seek(0, SeekOrigin.Begin);

            using (ZipArchive zipData = new ZipArchive(mStream, ZipArchiveMode.Read, leaveOpen: true))
            {
                //check for office xml formats
                var officeXml = CheckForOpenXMLDocument(zipData);

                if (officeXml != null)
                    return officeXml;

                //check for open office formats
                var openOffice = CheckForOpenDocument(zipData);

                if (openOffice != null)
                    return openOffice;
            }

            if (locallyCreatedStream)
                mStream.Dispose();

            return MimeTypes.ZIP;
        }

        public FileType CheckForOpenXMLDocument(ZipArchive zipData)
        {
            foreach (var entry in zipData.Entries)
            {
                if (entry.FullName.StartsWith("word/"))
                    return MimeTypes.WORDX;
                else if (entry.FullName.StartsWith("xl/"))
                    return MimeTypes.EXCELX;
                else if (entry.FullName.StartsWith("ppt/"))
                    return MimeTypes.PPTX;
            }

            return null;
        }

        //check for open doc formats
        public FileType CheckForOpenDocument(ZipArchive zipFile)
        {
            ZipArchiveEntry ooMimeType = null;

            foreach (var entry in zipFile.Entries)
            {
                if (entry.FullName == "mimetype")
                {
                    ooMimeType = entry;
                    break;
                }
            }

            if (ooMimeType is null)
                return null;

            using (var textReader = new StreamReader(ooMimeType.Open()))
            {
                var mimeType = textReader.ReadToEnd();

                if (mimeType == MimeTypes.ODT.Mime)
                    return MimeTypes.ODT;
                else if (mimeType == MimeTypes.ODS.Mime)
                    return MimeTypes.ODS;
                else if (mimeType == MimeTypes.ODP.Mime)
                    return MimeTypes.ODP;
                else if (mimeType == MimeTypes.ODG.Mime)
                    return MimeTypes.ODG;
                else
                    return null;
            }
        }
    }
}
